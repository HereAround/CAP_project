####################################################################################
##
## TruncationsOfGradedModulePresentationsForCAP package
##
##  Copyright 2016, Martin Bies,       ITP Heidelberg
##
##  Chapter Wrapper for generators of semigroups and hyperplane constraints of cones
##
####################################################################################



############################################
##
##  Section GAP Categories
##
############################################

##
DeclareRepresentation( "IsSemigroupGeneratorListRep",
                       IsSemigroupGeneratorList and IsAttributeStoringRep,
                       [ ] );

BindGlobal( "TheFamilyOfSemigroupGeneratorLists",
        NewFamily( "TheFamilyOfSemigroupGeneratorLists" ) );

BindGlobal( "TheTypeOfSemigroupGeneratorLists",
        NewType( TheFamilyOfSemigroupGeneratorLists,
                IsSemigroupGeneratorListRep ) );

##
DeclareRepresentation( "IsConeHPresentationListRep",
                       IsConeHPresentationList and IsAttributeStoringRep,
                       [ ] );

BindGlobal( "TheFamilyOfConeHPresentationLists",
        NewFamily( "TheFamilyOfConeHPresentationLists" ) );

BindGlobal( "TheTypeOfConeHPresentationLists",
        NewType( TheFamilyOfConeHPresentationLists,
                IsConeHPresentationListRep ) );

##
DeclareRepresentation( "IsConeVPresentationListRep",
                       IsConeVPresentationList and IsAttributeStoringRep,
                       [ ] );

BindGlobal( "TheFamilyOfConeVPresentationLists",
        NewFamily( "TheFamilyOfConeVPresentationLists" ) );

BindGlobal( "TheTypeOfConeVPresentationLists",
        NewType( TheFamilyOfConeVPresentationLists,
                IsConeVPresentationListRep ) );

##
DeclareRepresentation( "IsAffineSemigroupRep",
                       IsAffineSemigroup and IsAttributeStoringRep,
                       [ ] );

BindGlobal( "TheFamilyOfAffineSemigroups",
        NewFamily( "TheFamilyOfAffineSemigroups" ) );

BindGlobal( "TheTypeOfAffineSemigroups",
        NewType( TheFamilyOfAffineSemigroups,
                IsAffineSemigroupRep ) );

##
DeclareRepresentation( "IsAffineConeSemigroupRep",
                       IsAffineConeSemigroup and IsAttributeStoringRep,
                       [ ] );

BindGlobal( "TheFamilyOfAffineConeSemigroups",
        NewFamily( "TheFamilyOfAffineConeSemigroups" ) );

BindGlobal( "TheTypeOfAffineConeSemigroups",
        NewType( TheFamilyOfAffineConeSemigroups,
                IsAffineConeSemigroupRep ) );



############################################
##
#! @Section Constructors
##
############################################

InstallMethod( SemigroupGeneratorList,
               [ IsList, IsInt ],
  function( list_of_generators, embedding_dimension )
    local helper_list, i, j, cone, hpres, vpres, sg_generator_list;

    if embedding_dimension < 0 then
      Error( "the embedding dimension cannot be negative" );
      return;
    fi;

    # we have to check that 
    # (1) all entries of the list_of_generators are of the same length 'embedding_dimension'
    # (2) all entries are integers

    # @ (1)
    helper_list := DuplicateFreeList( 
                           List( [ 1 .. Length( list_of_generators ) ], i -> Length( list_of_generators[ i ] ) ) );
    if Length( helper_list ) > 1 then
      Error( "all generators have to be of the same length");
      return;
    elif helper_list[ 1 ] <> embedding_dimension then
      Error( Concatenation( "the generators must be of the length", String( embedding_dimension ) ) );
      return;
    fi;

    # @ (2)
    for i in [ 1 .. Length( list_of_generators ) ] do

      for j in [ 1 .. Length( list_of_generators[ i ] ) ] do

        if not IsInt( list_of_generators[ i ][ j ] ) then
          Error( "the entries of all generators must be integers" );
          return;
        fi;

      od;

    od;

    # cone-semigroup?
    if DecideIfIsConeSemigroupGeneratorList( list_of_generators ) then

      # now try to return the ConeHPresentation list associated to the cone generated by the semigroup_generator_list
      cone := NmzCone( [ "integral_closure", list_of_generators ] );

      # check if the cone is full-dimensional, so that normaliz can compute an H-presentation
      NmzCompute( cone );
      if NmzRank( cone ) <> NmzEmbeddingDimension( cone ) then
        hpres := fail;
      else
        hpres := ConeHPresentationList( NmzSupportHyperplanes( cone ), embedding_dimension );
      fi;

      vpres := ConeVPresentationList( list_of_generators, embedding_dimension );

      # now objectify with these presentations
      sg_generator_list := rec();
      ObjectifyWithAttributes( sg_generator_list, TheTypeOfSemigroupGeneratorLists,
                               UnderlyingList, DuplicateFreeList( list_of_generators ),
                               EmbeddingDimension, embedding_dimension,
                               UnderlyingConeHPresentationList, hpres,
                               UnderlyingConeVPresentationList, vpres
                            );

      # set AffineConeSemigroup property
      SetIsSemigroupOfConeGeneratorList( sg_generator_list, true );

    else

      # now objectify with these presentations
      sg_generator_list := rec();
      ObjectifyWithAttributes( sg_generator_list, TheTypeOfSemigroupGeneratorLists,
                               UnderlyingList, DuplicateFreeList( list_of_generators ),
                               EmbeddingDimension, embedding_dimension,
                               UnderlyingConeHPresentationList, fail,
                               UnderlyingConeVPresentationList, fail
                            );

      # set AffineConeSemigroup property
      SetIsSemigroupOfConeGeneratorList( sg_generator_list, false );

    fi;

    # decide if the semigroup is empty
    if Length( UnderlyingList( sg_generator_list ) ) = 0 then
      SetIsEmpty( sg_generator_list, true );
    else
      SetIsEmpty( sg_generator_list, false );
    fi;

    # and return the resulting object
    return sg_generator_list;

end );

# convenience method which deduces the embedding dimension (if possible) from a given list of generators
InstallMethod( SemigroupGeneratorList,
               [ IsList ],
  function( list_of_generators )

    if Length( list_of_generators ) = 0 then
      Error( "the embedding dimension cannot be deduced uniquely from the given list of semigroup generators" );
      return;
    else
      return SemigroupGeneratorList( list_of_generators, Length( list_of_generators[ 1 ] ) );
    fi;

end );

InstallMethod( ConeHPresentationList,
               [ IsList, IsInt ],
  function( list_of_hconstraints, embedding_dimension )
    local helper_list, i, j, cone_hpresentation_list;

    # we expect at least one h-constraint
    if embedding_dimension < 0 then
      Error( "the embedding dimension must be non-negative" );
      return;
    fi;

    # we have to check that 
    # (1) all entries of the list_of_hconstraints are of the same length
    # (2) all entries are integers

    # @ (1)
    helper_list := DuplicateFreeList( 
                           List( [ 1 .. Length( list_of_hconstraints ) ], i -> Length( list_of_hconstraints[ i ] ) ) );
    if Length( helper_list ) > 1 then
      Error( "all h-constraints have to be of the same length");
      return;
    elif helper_list[ 1 ] <> embedding_dimension then
      Error( Concatenation( "the h-constraints must be of length ", String( embedding_dimension ) ) );
      return;
    fi;

    # @ (2)
    for i in [ 1 .. Length( list_of_hconstraints ) ] do

      for j in [ 1 .. Length( list_of_hconstraints[ i ] ) ] do

        if not IsInt( list_of_hconstraints[ i ][ j ] ) then
          Error( "the entries of all h-constraints must be integers" );
          return;
        fi;

      od;

    od;

    # all checks passed, so create the ConeHPresentationList
    cone_hpresentation_list := rec();
    ObjectifyWithAttributes( cone_hpresentation_list, TheTypeOfConeHPresentationLists,
                             UnderlyingList, DuplicateFreeList( list_of_hconstraints ),
                             EmbeddingDimension, embedding_dimension
                            );

    # decide if the list is empty and set the property accordingly
    if Length( UnderlyingList( cone_hpresentation_list ) ) = 0 then
      SetIsEmpty( cone_hpresentation_list, true );
    else
      SetIsEmpty( cone_hpresentation_list, false );
    fi;

    # and return this object
    return cone_hpresentation_list;

end );

InstallMethod( ConeHPresentationList,
               [ IsList ],
  function( list_of_hconstraints )

    if Length( list_of_hconstraints ) = 0 then
      Error( "the embedding dimension cannot be deduced uniquely from the given list of h-constraints" );
      return;
    else
      return ConeHPresentationList( list_of_hconstraints, Length( list_of_hconstraints[ 1 ] ) );
    fi;

end );

InstallMethod( ConeHPresentationList,
               [ IsNormalizCone ],
  function( cone )
    local cone_hpresentation_list;

    # check if the cone is full-dimensional, so that normaliz can compute an H-presentation
    NmzCompute( cone );
    if NmzRank( cone ) <> NmzEmbeddingDimension( cone ) then

      Error( "Normaliz cannot compute an H-presentation of cones that are not full-dimensional" );
      return;

    fi;

    # if normaliz can provide an h-presentation, we can now compute a ConeHPresentationList
    cone_hpresentation_list := rec();
    ObjectifyWithAttributes( cone_hpresentation_list, TheTypeOfConeHPresentationLists,
                             UnderlyingList, NmzSupportHyperplanes( cone ),
                             EmbeddingDimension, NmzEmbeddingDimension( cone )
                            );

    # decide if the list is empty and set the property accordingly
    if Length( UnderlyingList( cone_hpresentation_list ) ) = 0 then
      SetIsEmpty( cone_hpresentation_list, true );
    else
      SetIsEmpty( cone_hpresentation_list, false );
    fi;

    # and return this object
    return cone_hpresentation_list;

end );

InstallMethod( ConeVPresentationList,
               [ IsList, IsInt ],
  function( list_of_generators, embedding_dimension )
    local helper_list, i, j, cone_vpresentation_list;

    # we expect at least one ray
    if embedding_dimension < 0 then
      Error( "the embedding dimension must be non-negative" );
      return;
    fi;

    # we have to check that 
    # (1) all entries of the list_of_generators are of the same length
    # (2) all entries are integers

    # @ (1)
    helper_list := DuplicateFreeList( 
                           List( [ 1 .. Length( list_of_generators ) ], i -> Length( list_of_generators[ i ] ) ) );
    if Length( helper_list ) > 1 then
      Error( "all generators have to be of the same length");
      return;
    elif helper_list[ 1 ] <> embedding_dimension then
      Error( Concatenation( "the generators must be of length ", String( embedding_dimension ) ) );
      return;
    fi;

    # @ (2)
    for i in [ 1 .. Length( list_of_generators ) ] do

      for j in [ 1 .. Length( list_of_generators[ i ] ) ] do

        if not IsInt( list_of_generators[ i ][ j ] ) then
          Error( "the entries of all generators must be integers" );
          return;
        fi;

      od;

    od;

    # all checks passed, so create the ConeHPresentationList
    cone_vpresentation_list := rec();
    ObjectifyWithAttributes( cone_vpresentation_list, TheTypeOfConeVPresentationLists,
                             UnderlyingList, DuplicateFreeList( list_of_generators ),
                             EmbeddingDimension, embedding_dimension
                            );

    # decide if the list is empty and set the property accordingly
    if Length( UnderlyingList( cone_vpresentation_list ) ) = 0 then
      SetIsEmpty( cone_vpresentation_list, true );
    else
      SetIsEmpty( cone_vpresentation_list, false );
    fi;

    # and return this object
    return cone_vpresentation_list;

end );

InstallMethod( ConeVPresentationList,
               [ IsList ],
  function( list_of_generators )

    if Length( list_of_generators ) = 0 then
      Error( "the embedding dimension cannot be deduced uniquely from the given list of generators" );
      return;
    else
      return ConeVPresentationList( list_of_generators, Length( list_of_generators[ 1 ] ) );
    fi;

end );

InstallMethod( ConeVPresentationList,
               [ IsNormalizCone ],
  function( cone )
    local underlying_list, cone_vpresentation_list;

    # check if the cone is full-dimensional, so that normaliz can compute an H-presentation
    NmzCompute( cone );
    if not NmzHasConeProperty( cone,"HilbertBasis" ) then

      Error( "Normaliz could not compute a Hilbert basis of the semigroup of the given cone" );
      return;

    fi;

    # if normaliz can provide a Hilbert basis, we use it
    underlying_list := NmzHilbertBasis( cone );
    cone_vpresentation_list := rec();
    ObjectifyWithAttributes( cone_vpresentation_list, TheTypeOfConeVPresentationLists,
                             UnderlyingList, underlying_list,
                             EmbeddingDimension, NmzEmbeddingDimension( cone )
                            );

    # decide if the list is empty and set the property accordingly
    if Length( UnderlyingList( cone_vpresentation_list ) ) = 0 then
      SetIsEmpty( cone_vpresentation_list, true );
    else
      SetIsEmpty( cone_vpresentation_list, false );
    fi;

    # and return this object
    return cone_vpresentation_list;

end );

InstallMethod( AffineConeSemigroup,
               [ IsNormalizCone, IsList ],
  function( cone, offset_point )
    local i, embedding_dim, affine_cone_semigroup;

    # now check that the offset_point lies in the same lattice as the semigroup of the cone
    NmzCompute( cone );
    if not Length( offset_point ) = NmzEmbeddingDimension( cone ) then
      Error( "The offset_point and the semigroup of the cone are not embedded into isomorphic lattices" );
      return;
    fi;
    for i in [ 1 .. Length( offset_point ) ] do
      if not IsInt( offset_point[ i ] ) then
        Error( "The offset_point must be given as a list of integers" );
        return;
      fi;
    od;

    # we have found that the input is valid, so collect the information that we need about the cone
    embedding_dim := Length( offset_point );
    affine_cone_semigroup := rec();
    if NmzHasConeProperty( cone, "HilbertBasis" ) and NmzRank( cone ) = NmzEmbeddingDimension( cone ) then

      ObjectifyWithAttributes( affine_cone_semigroup, TheTypeOfAffineConeSemigroups,
                          Offset, offset_point,
                          UnderlyingConeVPresentationList, ConeVPresentationList( NmzHilbertBasis( cone ), embedding_dim ),
                          UnderlyingConeHPresentationList, ConeHPresentationList( NmzSupportHyperplanes( cone ), embedding_dim ),
                          EmbeddingDimension, embedding_dim
                          );

    elif NmzHasConeProperty( cone, "HilbertBasis" ) and NmzRank( cone ) <> NmzEmbeddingDimension( cone ) then

      ObjectifyWithAttributes( affine_cone_semigroup, TheTypeOfAffineConeSemigroups,
                               Offset, offset_point,
                               UnderlyingConeVPresentationList, ConeVPresentationList( NmzHilbertBasis( cone ), embedding_dim ),
                               EmbeddingDimension, embedding_dim
                            );

    fi;

    # and return this object
    return affine_cone_semigroup;

end );

InstallMethod( AffineConeSemigroup,
               [ IsConeVPresentationList, IsList ],
  function( cone_vpresentation_list, offset_point )
    local cone, i, embedding_dim, affine_cone_semigroup;

    # compute the cone
    cone := NmzCone( [ "integral_closure", UnderlyingList( cone_vpresentation_list ) ] );
    NmzCompute( cone );

    # now check that the offset_point lies in the same lattice as the semigroup of the cone
    if not Length( offset_point ) = NmzEmbeddingDimension( cone ) then
      Error( "The offset_point and the semigroup of the cone are not embedded into isomorphic lattices" );
      return;
    fi;
    for i in [ 1 .. Length( offset_point ) ] do
      if not IsInt( offset_point[ i ] ) then
        Error( "The offset_point must be given as a list of integers" );
        return;
      fi;
    od;

    # we have found that the input is valid, so collect the information that we need about the cone
    embedding_dim := Length( offset_point );
    affine_cone_semigroup := rec();
    if NmzRank( cone ) = NmzEmbeddingDimension( cone ) then

      ObjectifyWithAttributes( affine_cone_semigroup, TheTypeOfAffineConeSemigroups,
                          Offset, offset_point,
                          UnderlyingConeVPresentationList, cone_vpresentation_list,
                          UnderlyingConeHPresentationList, ConeHPresentationList( NmzSupportHyperplanes( cone ), embedding_dim ),
                          EmbeddingDimension, embedding_dim
                          );

    elif NmzRank( cone ) <> NmzEmbeddingDimension( cone ) then

      ObjectifyWithAttributes( affine_cone_semigroup, TheTypeOfAffineConeSemigroups,
                               Offset, offset_point,
                               UnderlyingConeVPresentationList, cone_vpresentation_list,
                               EmbeddingDimension, embedding_dim
                            );

    fi;

    # now check if this affine_cone_semigroup is trivial
    if IsEmpty( cone_vpresentation_list ) then
      SetIsTrivial( affine_cone_semigroup, true );
    else
      SetIsTrivial( affine_cone_semigroup, false );
    fi;

    # and return this object
    return affine_cone_semigroup;

end );

InstallMethod( AffineConeSemigroup,
               [ IsConeHPresentationList, IsList ],
  function( cone_hpresentation_list, offset_point )
    local cone, i, embedding_dim, affine_cone_semigroup;

    # compute the cone
    cone := NmzCone( [ "inequalities", UnderlyingList( cone_hpresentation_list ) ] );
    NmzCompute( cone );

    # now check that the offset_point lies in the same lattice as the semigroup of the cone
    if not Length( offset_point ) = NmzEmbeddingDimension( cone ) then
      Error( "The offset_point and the semigroup of the cone are not embedded into isomorphic lattices" );
      return;
    fi;
    for i in [ 1 .. Length( offset_point ) ] do
      if not IsInt( offset_point[ i ] ) then
        Error( "The offset_point must be given as a list of integers" );
        return;
      fi;
    od;

    # we have found that the input is valid, so collect the information that we need about the cone
    embedding_dim := Length( offset_point );
    affine_cone_semigroup := rec();
    if NmzHasConeProperty( cone, "HilbertBasis" ) then

      # objectify
      ObjectifyWithAttributes( affine_cone_semigroup, TheTypeOfAffineConeSemigroups,
                               Offset, offset_point,
                               UnderlyingConeVPresentationList, ConeVPresentationList( NmzHilbertBasis( cone ), embedding_dim ),
                               UnderlyingConeHPresentationList, cone_hpresentation_list,
                               EmbeddingDimension, embedding_dim
                            );

      # now check if this affine_cone_semigroup is trivial - this I can only do if we can compute a v-presentation
      if IsEmpty( UnderlyingConeVPresentationList( affine_cone_semigroup ) ) then
        SetIsTrivial( affine_cone_semigroup, true );
      else
        SetIsTrivial( affine_cone_semigroup, false );
      fi;

    else

      # objectify
      ObjectifyWithAttributes( affine_cone_semigroup, TheTypeOfAffineConeSemigroups,
                               Offset, offset_point,
                               UnderlyingConeHPresentationList, cone_hpresentation_list,
                               EmbeddingDimension, embedding_dim
                            );

      # unforunately, here no easy check of triviality is possible
      # -> is left out therefore

    fi;

    # and return this object
    return affine_cone_semigroup;

end );

InstallMethod( AffineSemigroup,
               [ IsSemigroupGeneratorList, IsList ],
  function( semigroup_generator_list, offset_point )
    local conversion, i, affine_semigroup;

    if IsSemigroupOfConeGeneratorList( semigroup_generator_list ) then
      return AffineConeSemigroup( UnderlyingConeVPresentationList( semigroup_generator_list ), offset_point );
    fi;

    # now check that the offset_point lies in the same lattice as the semigroup of the cone
    if not Length( offset_point ) = EmbeddingDimension( semigroup_generator_list ) then
      Error( "The offset_point and the semigroup are not embedded into isomorphic lattices" );
      return;
    fi;
    for i in [ 1 .. Length( offset_point ) ] do
      if not IsInt( offset_point[ i ] ) then
        Error( "The offset_point must be given as a list of integers" );
        return;
      fi;
    od;

    # we have found that the input is valid, so collect the information that we need about the cone
    affine_semigroup := rec();
    ObjectifyWithAttributes( affine_semigroup, TheTypeOfAffineSemigroups,
                             UnderlyingSemigroupGeneratorList, semigroup_generator_list,
                             Offset, offset_point,
                             EmbeddingDimension, Length( offset_point )
                            );

    # check if this affine_semigroup is trivial
    if IsEmpty( semigroup_generator_list ) then
      SetIsTrivial( affine_semigroup, true );
    else
      SetIsTrivial( affine_semigroup, false );
    fi;

    # decide if this is an AffineConeSemigroup
    SetIsAffineSemigroupOfCone( affine_semigroup, false );

    # and return this object
    return affine_semigroup;

end );



####################################
##
## String
##
####################################

InstallMethod( String,
              [ IsSemigroupGeneratorList ],
  function( semigroup_generator_list )

    # if empty
    if IsEmpty( semigroup_generator_list ) then
      return Concatenation( "An empty list of generators of a semigroup of Z^",
                             String( EmbeddingDimension( semigroup_generator_list ) ) 
                           );
    # otherwise
    else
      if IsSemigroupOfConeGeneratorList( semigroup_generator_list ) = true then
        return Concatenation( "A list of ",
                              String( Length( UnderlyingList( semigroup_generator_list ) ) ),
                              " generators of a cone-semigroup in Z^",
                              String( EmbeddingDimension( semigroup_generator_list ) ) 
                             );
      elif IsSemigroupOfConeGeneratorList( semigroup_generator_list ) = false then
        return Concatenation( "A list of ",
                              String( Length( UnderlyingList( semigroup_generator_list ) ) ),
                              " generators of a non-cone semigroup in Z^",
                              String( EmbeddingDimension( semigroup_generator_list ) ) 
                             );
      else
        return Concatenation( "A list of ",
                              String( Length( UnderlyingList( semigroup_generator_list ) ) ),
                              " generators of a semigroup in Z^",
                              String( EmbeddingDimension( semigroup_generator_list ) ) 
                             );
      fi;
    fi;

end );

InstallMethod( String,
              [ IsConeHPresentationList ],
  function( cone_hpresentation_list )

    # if empty
    if IsEmpty( cone_hpresentation_list ) then
      return Concatenation( "An empty list of hyperplane constraints of a cone in Z^",
                            String( EmbeddingDimension( cone_hpresentation_list ) ) 
                           );
    # otherwise
    else
      return Concatenation( "A list of ",
                            String( Length( UnderlyingList( cone_hpresentation_list ) ) ),
                            " hyperplane constraints of a cone in Z^",
                            String( EmbeddingDimension( cone_hpresentation_list ) ) 
                           );
    fi;

end );

InstallMethod( String,
              [ IsConeVPresentationList ],
  function( cone_vpresentation_list )

    # if empty
    if IsEmpty( cone_vpresentation_list ) then
      return Concatenation( "An empty list of vertex generators of a cone in Z^",
                            String( EmbeddingDimension( cone_vpresentation_list ) ) 
                           );
    # otherwise
    else
      return Concatenation( "A list of ",
                            String( Length( UnderlyingList( cone_vpresentation_list ) ) ),
                            " vertex generators of a cone in Z^",
                            String( EmbeddingDimension( cone_vpresentation_list ) ) 
                           );
    fi;

end );

InstallMethod( String,
              [ IsAffineConeSemigroup ],
  function( affine_cone_semigroup )

    # if the triviality of the semigroup has been decided, then adjust the output accordingly
    if HasIsTrivial( affine_cone_semigroup ) then

      if IsTrivial( affine_cone_semigroup ) then
        return Concatenation( "A trivial affine cone-semigroup in Z^",
                              String( EmbeddingDimension( affine_cone_semigroup ) ) );
      else
        return Concatenation( "A non-trivial affine cone-semigroup in Z^",
                              String( EmbeddingDimension( affine_cone_semigroup ) ) );
      fi;

    else #otherwise we use the standard output

      return Concatenation( "An affine cone-semigroup in Z^",
                            String( EmbeddingDimension( affine_cone_semigroup ) ) );

    fi;

end );

InstallMethod( String,
              [ IsAffineSemigroup ],
  function( affine_semigroup )

    if IsTrivial( affine_semigroup ) then
      return Concatenation( "A trivial affine semigroup in Z^",
                              String( EmbeddingDimension( affine_semigroup ) ) );
    else
      if IsAffineSemigroupOfCone( affine_semigroup ) = true then
        return Concatenation( "A non-trivial affine cone-semigroup in Z^",
                              String( EmbeddingDimension( affine_semigroup ) ) );
      elif IsAffineSemigroupOfCone( affine_semigroup ) = false then
        return Concatenation( "A non-trivial affine non-cone semigroup in Z^",
                              String( EmbeddingDimension( affine_semigroup ) ) );
      else
        return Concatenation( "A non-trivial affine semigroup in Z^",
                              String( EmbeddingDimension( affine_semigroup ) ) );
      fi;
    fi;

end );



####################################
##
## Display
##
####################################

InstallMethod( Display,
               [ IsSemigroupGeneratorList ],
  function( semigroup_generator_list )

    if IsEmpty( semigroup_generator_list ) then
      Print( Concatenation( String( semigroup_generator_list ), "\n" ) );
    else
      if IsSemigroupOfConeGeneratorList( semigroup_generator_list ) = true then
        Print( Concatenation( String( semigroup_generator_list ), " - Hilbert basis is as follows: \n" ) );
        Display( UnderlyingList( semigroup_generator_list ) );
        Print( "\n" );
      else
        Print( Concatenation( String( semigroup_generator_list ), " - generators are as follows: \n" ) );
        Display( UnderlyingList( semigroup_generator_list ) );
        Print( "\n" );
      fi;
    fi;

end );

InstallMethod( Display,
               [ IsConeHPresentationList ],
  function( cone_hpresentation_list )

    if IsEmpty( cone_hpresentation_list ) then
      Print( Concatenation( String( cone_hpresentation_list ), "\n" ) );
    else
      Print( Concatenation( String( cone_hpresentation_list ), " - h-constraints are as follows: \n" ) );
      Display( UnderlyingList( cone_hpresentation_list ) );
      Print( "\n" );
    fi;

end );

InstallMethod( Display,
               [ IsConeVPresentationList ],
  function( cone_vpresentation_list )

    if IsEmpty( cone_vpresentation_list ) then
      Print( Concatenation( String( cone_vpresentation_list ), "\n" ) );
    else
      Print( Concatenation( String( cone_vpresentation_list ), " - ray generators are as follows: \n" ) );
      Display( UnderlyingList( cone_vpresentation_list ) );
      Print( "\n" );
    fi;

end );

InstallMethod( Display,
              [ IsAffineConeSemigroup ],
  function( affine_cone_semigroup )

    if HasIsTrivial( affine_cone_semigroup ) then

      if IsTrivial( affine_cone_semigroup ) then
        Print( Concatenation( String( affine_cone_semigroup ), "\n" ) );
        Print( Concatenation( "Offset: ", String( Offset( affine_cone_semigroup ) ), "\n" ) );
      else
        Print( Concatenation( String( affine_cone_semigroup ), "\n" ) );
        Print( Concatenation( "Offset: ", String( Offset( affine_cone_semigroup ) ), "\n" ) );
        if HasUnderlyingConeVPresentationList( affine_cone_semigroup ) then
          Print( Concatenation( "Cone generators: ", 
                 String( UnderlyingList( UnderlyingConeVPresentationList( affine_cone_semigroup ) ) ) ) );
        else
          Print( Concatenation( "Cone h-presentation: ",
                 String( UnderlyingList( UnderlyingConeHPresentationList( affine_cone_semigroup ) ) ) ) );
        fi;
        Print( "\n" );

      fi;
    else
      Print( Concatenation( String( affine_cone_semigroup ), "\n" ) );
      Print( Concatenation( "Offset: ", String( Offset( affine_cone_semigroup ) ), "\n" ) );

      if HasUnderlyingConeVPresentationList( affine_cone_semigroup ) then
        Print( Concatenation( "Cone generators: ", 
               String( UnderlyingList( UnderlyingConeVPresentationList( affine_cone_semigroup ) ) ) ) );
      else
        Print( Concatenation( "Cone h-presentation: ",
               String( UnderlyingList( UnderlyingConeHPresentationList( affine_cone_semigroup ) ) ) ) );
      fi;
      Print( "\n" );
    fi;

end );

InstallMethod( Display,
              [ IsAffineSemigroup ],
  function( affine_semigroup )

    if IsTrivial( affine_semigroup ) then
      Print( Concatenation( String( affine_semigroup ), "\n" ) );
      Print( Concatenation( "Offset: ", String( Offset( affine_semigroup ) ), "\n" ) );
    else
      if IsAffineSemigroupOfCone( affine_semigroup ) = true then
        Print( Concatenation( String( affine_semigroup ), "\n" ) );
        Print( Concatenation( "Offset: ", String( Offset( affine_semigroup ) ), "\n" ) );
        Print( Concatenation( "Hilbert basis: ",
               String( UnderlyingList( UnderlyingSemigroupGeneratorList( affine_semigroup ) ) ) ) );
        Print( "\n" );
      else
        Print( Concatenation( String( affine_semigroup ), "\n" ) );
        Print( Concatenation( "Offset: ", String( Offset( affine_semigroup ) ), "\n" ) );
        Print( Concatenation( "Semigroup generators: ",
               String( UnderlyingList( UnderlyingSemigroupGeneratorList( affine_semigroup ) ) ) ) );
        Print( "\n" );
      fi;
    fi;

end );



####################################
##
## ViewObj
##
####################################

InstallMethod( ViewObj,
               [ IsSemigroupGeneratorList ],
  function( semigroup_generator_list )

    Print( Concatenation( "<", String( semigroup_generator_list ), ">" ) );

end );

InstallMethod( ViewObj,
               [ IsConeHPresentationList ],
  function( cone_hpresentation_list )

    Print( Concatenation( "<", String( cone_hpresentation_list ), ">" ) );

end );

InstallMethod( ViewObj,
               [ IsConeVPresentationList ],
  function( cone_vpresentation_list )

    Print( Concatenation( "<", String( cone_vpresentation_list ), ">" ) );

end );

InstallMethod( ViewObj,
              [ IsAffineConeSemigroup ],
  function( affine_cone_semigroup )

    Print( Concatenation( "<", String( affine_cone_semigroup ), ">" ) );

end );

InstallMethod( ViewObj,
              [ IsAffineSemigroup ],
  function( affine_semigroup )

    Print( Concatenation( "<", String( affine_semigroup ), ">" ) );

end );



############################################
##
##  Section Operations
##
############################################

InstallMethod( DecideIfIsConeSemigroupGeneratorList,
               "for semigroup_generator_lists",
               [ IsList ],
  function( list_of_generators )
    local cone, hilbert_basis, i, pos;

    # extract the necessary data
    cone := NmzCone( [ "integral_closure", list_of_generators ] );
    NmzCompute( cone );

    # check if Normaliz can compute a Hilbert basis
    if not NmzHasConeProperty( cone, "HilbertBasis" ) then

      return fail;

    fi;

    # then extract the Hilbet basis
    hilbert_basis := NmzHilbertBasis( cone );

    # now compare list_of_generators and hilbert_basis modulo potential permutations
    if Length( hilbert_basis ) <> Length( list_of_generators ) then
      return false;
    fi;

    # find matches of the elements in the list_of_generators in hilbert_basis and then delete those elements from
    # the hilbert_basis
    for i in [ 1 .. Length( list_of_generators ) ] do

      pos := 1;
      while not list_of_generators[ i ] = hilbert_basis[ pos ] do
        pos := pos + 1;

        if pos > Length( hilbert_basis ) then
          return false;
        fi;

      od;

      # found match at position "pos" in hilbert_basis, so delete this entry from hilbert_basis
      Remove( hilbert_basis, pos );

    od;

    # and give the final answer
    return Length( hilbert_basis ) = 0;

end );

InstallMethod( DecideIfIsAffineConeSemigroup,
               "for semigroup_generator_lists",
               [ IsAffineSemigroup ],
  function( affine_semigroup )

    return IsAffineConeSemigroup( UnderlyingSemigroupGeneratorList( affine_semigroup ) );

end );



#############################################################################
##
##  Section Check if point is contained in cone or an affine (cone) semigroup
##
#############################################################################

# check if a point lies in a cone given by an H-presentation
InstallMethod( PointContainedInCone,
               " for a cone given by H-constraints, a list specifying a point ",
               [ IsConeHPresentationList, IsList ],
  function( cone_h_presentation_list, point )
    local i, constraint;

    # check if the point lies in the same lattice as the affine_cone_semigroup
    if Length( point ) <> EmbeddingDimension( cone_h_presentation_list ) then
      Error( "The point and the semigroup of the cone are not embedded into the same lattice" );
      return;
    fi;

    # if the list of constraints is empty, the point is contained
    if IsEmpty( cone_h_presentation_list ) then
      return true;
    fi;

    # now look at the non-trivial cases - compute the hyperplane constraints
    for i in [ 1..Length( UnderlyingList( cone_h_presentation_list ) ) ] do

      # compute constraint
      constraint := Sum( List( [ 1..Length( UnderlyingList( cone_h_presentation_list )[ i ] ) ], 
                                           x -> UnderlyingList( cone_h_presentation_list )[ i ][ x ] * point[ x ] ) );

      # if non-negative, the point satisfies this constraint
      if constraint < 0 then
	return false;
      fi;

    od;

    # all tests passed, so return true
    return true;

end );

# check if a point lies in a cone given by a V-presentation
InstallMethod( PointContainedInCone,
               " for a cone given by V-presentation, a list specifying a point ",
               [ IsConeVPresentationList, IsList ],
  function( cone_vpresentation_list, point )
    local cone;

    # check if the point lies in the same lattice as the affine_cone_semigroup
    if Length( point ) <> EmbeddingDimension( cone_vpresentation_list ) then
      Error( "The point and the semigroup of the cone are not embedded into the same lattice" );
      return;
    fi;

    # if there are no ray-generators, then the point is contained iff the point is 0 in the lattice
    if IsEmpty( cone_vpresentation_list ) then
      if point = List( [ 1 .. Length( point ) ], k -> 0 ) then
        return true;
      fi;
    fi;

    # now check the non-trivial case by computing an H-presentation
    # here we could also use 4ti2 immediately, so that no conversion is needed!
    cone := NmzCone( [ "integral_closure", UnderlyingList( cone_vpresentation_list ) ] );
    NmzCompute( cone );
    if NmzRank( cone ) <> NmzEmbeddingDimension( cone ) then
      Error( "Normaliz cannot compute an H-presentation of cones that are not full-dimensional" );
      return;
    else
      return PointContainedInCone( ConeHPresentationList( NmzSupportHyperplanes( cone ) ), point );
    fi;

end );

# check if a point lies in a cone given by a Nmz-Cone
InstallMethod( PointContainedInCone,
               " for a Nmz-cone, a list specifying a point ",
               [ IsNormalizCone, IsList ],
  function( cone, point )

    NmzCompute( cone );
    if NmzRank( cone ) <> NmzEmbeddingDimension( cone ) then
      Error( "Normaliz cannot compute an H-presentation of cones that are not full-dimensional" );
      return;
    else
      return PointContainedInCone( ConeHPresentationList( NmzSupportHyperplanes( cone ) ), point );
    fi;

end );

# check if a point lies in a subsemigroup
InstallMethod( PointContainedInSemigroup,
               " for a subsemigroup given by a list of generators and a list specifying a point ",
               [ IsSemigroupGeneratorList, IsList ],
  function( semigroup_generator_list, point )
    local conversion, res;

    # check if the point lies in the same lattice as the affine_cone_semigroup
    if Length( point ) <> EmbeddingDimension( semigroup_generator_list ) then
      Error( "The point and the semigroup are not embedded into the same lattice" );
      return;
    fi;

    # check if semigroup_generator_list is empty, for this means that the point lies in the semigroup iff point = [ 0,...,0 ]
    if IsEmpty( semigroup_generator_list ) then
      if point = List( [ 1 .. Length( point ) ], k -> 0 ) then
        return true;
      fi;
    fi;

    # next check if the semigroup is the semigroup of a cone
    if IsSemigroupOfConeGeneratorList( semigroup_generator_list ) then
      return PointContainedInCone( ConeVPresentationList( UnderlyingList( semigroup_generator_list ) ), point );
    fi;

    # if that fails as well, we come to use 4ti2.
    # Recall that subsemigroup_generators = [ gen1, gens2, ..., genN ].
    # For use by 4ti2Interface, we need to transpose this list, i.e. the generators are written in the columns
    res := 4ti2Interface_zsolve_equalities_and_inequalities_in_positive_orthant( 
                                           TransposedMat( UnderlyingList( semigroup_generator_list ) ), point, [], [] );
    # the first entry of the returned list expresses the point in terms of the generators (if such a solution exists)
    # so the first entry has length 0 precisely if the point is NOT contained in the subsemigroup
    if Length( res[ 1 ] ) = 0 then
      return false;
    else
      return true;
    fi;

end );

# check if a point satisfies hyperplane constraints for a cone, thereby determining if the point lies in the cone
InstallMethod( PointContainedInAffineConeSemigroup,
               " for an affine cone semigroup, a list specifying a point ",
               [ IsAffineConeSemigroup, IsList ],
  function( affine_cone_semigroup, point )

    if HasUnderlyingConeHPresentationList( affine_cone_semigroup ) then
      return PointContainedInCone( UnderlyingConeHPresentationList( affine_cone_semigroup ), 
                                   point - Offset( affine_cone_semigroup ) 
                                  );
    else
      return PointContainedInCone( UnderlyingConeVPresentationList( affine_cone_semigroup ), 
                                   point - Offset( affine_cone_semigroup ) 
                                  );
    fi;

end );

# check if a point satisfies hyperplane constraints for a cone, thereby determining if the point lies in the cone
InstallMethod( PointContainedInAffineSemigroup,
               " for a cone given by H-constraints, a list specifying a point ",
               [ IsAffineSemigroup, IsList ],
  function( affine_semigroup, point )

   return PointContainedInSemigroup( UnderlyingSemigroupGeneratorList( affine_semigroup ),  point - Offset( affine_semigroup ) );

end );